{"ast":null,"code":"/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function (blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function (line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n  const candidate = {\n    foundation: parts[0],\n    component: {\n      1: 'rtp',\n      2: 'rtcp'\n    }[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4],\n    // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default:\n        // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function (candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function (line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function (line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function (codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function (line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function (codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function (line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function (codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function (line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function (line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function (mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function (line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(),\n    // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3)\n  };\n};\nSDPUtils.writeCryptoLine = function (parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function (keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n  };\n};\nSDPUtils.writeCryptoKeyParams = function (keyParams) {\n  return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10)\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function (params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  for (let i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n    const parts = line.substr(17).split(' ');\n    return parts.map(part => parseInt(part, 10));\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {\n          ssrc: secondarySsrc\n        };\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n  return rtcpParameters;\n};\nSDPUtils.writeRtcpParameters = function (rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function (mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function (mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0].substr(10).split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function (media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n  } else {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n      // FIXME: What should happen here?\n    }\n  }\n\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\nSDPUtils.getKind = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\nSDPUtils.parseMLine = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\nSDPUtils.parseOLine = function (mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function (blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}","map":{"version":3,"names":["SDPUtils","generateIdentifier","Math","random","toString","substr","localCName","splitLines","blob","trim","split","map","line","splitSections","parts","part","index","getDescription","sections","getMediaSections","shift","matchPrefix","prefix","filter","indexOf","parseCandidate","substring","candidate","foundation","component","protocol","toLowerCase","priority","parseInt","ip","address","port","type","i","length","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","undefined","writeCandidate","sdp","push","toUpperCase","join","parseIceOptions","parseRtpMap","parsed","payloadType","name","clockRate","channels","numChannels","writeRtpMap","codec","pt","preferredPayloadType","parseExtmap","id","direction","uri","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","Object","keys","params","forEach","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","attribute","value","parseSsrcGroup","semantics","ssrcs","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","tag","cryptoSuite","keyParams","sessionParams","slice","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","pwd","password","writeIceParameters","iceLite","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","mline","rtpmapline","fmtps","writeRtpDescription","kind","caps","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","primarySsrc","secondarySsrc","flows","apt","encParam","codecPayloadType","rtx","JSON","parse","stringify","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","obj","cname","rsize","reducedSize","compound","mux","writeRtcpParameters","parseMsid","spec","stream","track","planB","msidParts","parseSctpDescription","parseMLine","maxSizeLine","maxMessageSize","isNaN","sctpPort","fmt","sctpMapLines","writeSctpDescription","media","sctp","output","generateSessionId","writeSessionBoilerplate","sessId","sessVer","sessUser","sessionId","version","user","getDirection","getKind","isRejected","parseOLine","username","sessionVersion","netType","addressType","isValidSDP","charAt","module","exports"],"sources":["C:/Users/cnsi-3f-1/Desktop/React/RTSPtoWEBPlayer/examples/ReactComponent/node_modules/sdp/sdp.js"],"sourcesContent":["/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substr(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}